#tady bude gramatika

IDENTIFIKATOR ::= a..z|A..Z{0..0|a..z|A..Z}		# Identifikátory začínají písmenem a mají v sobě písmena či čísla
CISLO ::= ["$d"]0..9{0..9}[.0..9{0..9}]
BINARNICISLO ::= "$b" 0|1{0|1}						# binární a hex čísla pouze s $b nebo $h, u decimálního čísla není $d nutné
HEXADECIMALNICISLO ::= "$h" 0..9|A..F{0..9|A..F}
OPERATOR ::= +|-|/|*|^|&|!|"|"|and|or|not|==|!=|%|**|//|<>|>|<|>=|<=|&|"||"|!
RIDICIZNAKY ::= "("|")"|"{"|"}"|"["|"]"			# prakticky totéž co operátory
KEYWORD ::= if|else|elif|while|for|break|continue|return|function|in

#podminky
PROGRAM ::= { STATEMENT }

STATEMENT ::= ( CONDITION | LOOP | E | FDEF ) ;

BLOCK ::= OP_BRACES_LEFT { STATEMENT } OP_BRACES_RIGHT

CONDITION ::= KW_IF '(' E ')' BLOCK { KW_ELIF '(' E ')' BLOCK } [ KW_ELSE BLOCK ]

LOOP ::= KW_WHILE '(' E ')' BLOCK | KW_FOR ident KW_IN ( ident | FCALL | FIELD) BLOCK

FIELD :== OP_BRACKETS_LEFT [ F ]{ ,F } OP_BRACKETS_RIGHT # definice pole

FDEF :== KW_FUNCTION ident OP_PARENTHESES_LEFT ARGS OP_PARENTHESES_RIGHT BLOCK # definice funkce např mergesort = function (pole)

E ::= E1 [ OP_ASSIGN E1 ]
E1 ::= E2 { OP_OR E2 }
E2 ::= E3 { OP_AND E3 }
E3 ::= E4 { ( OP_EQUAL | OP_NOTEQUAL ) E4 }
E4 ::= E5 { ( OP_BIGGER | OP_SMALLER | OP_BIGGEROREQUAL | OP_SMALLERORERUAL ) E5 }
E5 ::= E6 { ( OP_ADD | OP_SUBSTRACT ) E6 }
E6 ::= E7 { ( OP_MULTIPLY | OP_MOCNIT | OP_FLOORDIVISION | OP_REMAINDER ) E7 }
E7 ::= [ OP_SUBSTRACT ] F
F ::= number | ident [ OP_BRACKETS_LEFT E OP_BRACKETS_RIGHT ] | FCALL | OP_PARENTHESES_LEFT E OP_PARENTHESES_RIGHT| FIELD

FCALL ::= ident OP_PARENTHESES_LEFT ARGS OP_PARENTHESES_RIGHT

ARGS ::= [ E { OP_COMMA E } ]
